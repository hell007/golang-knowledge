package counting

/*
# counting sort 计数排序

计数排序的实现一般有两种形式：基于辅助数组和基于桶排序。

计数排序的不足:可以看到辅助数组的长度和桶的数量由最大值和最小值决定，假如两者之差很大，而待排序数组又很小，那么就会导致辅助数组或桶大量浪费

//原理：计数排序是一种非基于元素比较的排序算法，而是将待排序数组元素转化为计数数组的索引值，从而间接使待排序数组具有顺序性。
//内部排序和外部排序：
//稳定性：稳定
//适用范围：
//算法步骤:
--基于辅助数组--
1.找出待排序的数组中最大和最小的元素.
2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项.
3.对所有的计数累加(从C中的第一个元素开始，每一项和前一项相加).
4.反向填充目标数组：将每个元素 i放在新数组的第C[i]项，每放一个元素就将C[i]减去1.

--基于桶排序--
1.针对个位数将元素放到对应的桶中
2.针对十位数将元素放到对应的桶中
3.针对百位数将元素放到对应的桶中
4.最终按照桶顺序输出得到排序结果

// 计数排序vs基数排序vs桶排序

这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

基数排序：根据键值的每位数字来分配桶；
计数排序：每个桶只存储单一键值；
桶排序：每个桶存储一定范围的数值；

总结：
基数排序和桶排序可以看成是计数排序的泛化版本，使用了某些措施优化排序过程。
在桶排序中当桶的个数取最大值(max-min+1)的时候，就变成了计数排序，所以计数排序时桶排序的一种特例。
基数排序可以看做是多轮桶排序，基数排序以有效位的角度，每个有效位都进行一轮桶排序。
当用最大值作为基数时，基数排序就退化成了计数排序
*/

func getMax(arr []int) int {
	max := arr[0]
	for i:=0; i<len(arr); i++ {
		if arr[i] > max {
			max = arr[i]
		}
	}
	return max
}

func getMin(arr []int) int  {
	min := arr[0]
	for _,value := range arr {
		if value < min {
			min = value
		}
	}
	return min
}

func Sort(arr []int) []int{
	length := len(arr)
	if length < 2 { return arr}

	//1.最大和最小
	max := getMax(arr)
	min := getMin(arr)

	// 2、新建桶数组
	bucket := make([]int, max - min + 1) //计数排序 与桶排序的区别
	sortedIndex := 0

	// 3、将待排序数组的值为桶的键，进行统计
	//bucket存放每个数出现的次数
	for i:=0; i<length; i++{
		bucket[arr[i] - min]++
	}

	// 4、将桶的数据输出
	for j:=0; j<max-min+1; j++ {
		for bucket[j] > 0 {
			arr[sortedIndex] = j + min
			sortedIndex += 1
			bucket[j] -= 1
		}
	}

	return arr
}