# 优化算法

其中`递推`、`递归(Recursion)`、`贪心算法(Greedy)`、`动态规划(DynamicProgram)`是以“相似或相同子问题”为核心的算法。

# 递归通用模型

```
//通用模型
func recurse()
{

//1递归的出口（隐含了递归的返回）

//2递归的传递

//3递归的处理

}
```

递归出口、递归处理、递归传递三者的顺序关系:

- 递归的传递：保证递归分治思想，即把大问题划分为同等结构的子问题；

- 递归出口：
确保递归传递的可穷尽性，所以肯定在递归传递之前；有返回型出口和逻辑型出口两种，返回型出口一定要注意返回值不要丢失，要谁调用返给谁。

- 递归处理：
分而治之的“治”。递归的使用场景一般是上一层的结果的计算需要依赖下一层的结果，所以递归的处理一般在递归的传递之后（传递下去再返回才能进行这层的计算）；